char	*ft_strlcpy(char *dst, const char *src, int dst_size)
{
	int y;

    y = 0;
    while (src[y] && y < (dst_size - 1))
    {
        dst[y] = src[y];
        y++;
    }
    dst[y] = '\0';
    return (dst);
}

char    *var_exist(t_struct *data, char *variable)
{
    int     i;
    char    *tmp;

    tmp = ft_strjoin(variable, "=");
    i = 0;
    while (data->envp[i])
    {
        if (!ft_strncmp(data->envp[i], tmp, ft_strlen(tmp)))
        {
            free(tmp);
            return (data->envp[i]);
        }
        i++;
    }
    free(tmp);
    return (NULL);
}

char	*replace_in_line(char *str, char *src, int n)
{
	int		i;

	i = 0;
	while (str[n] && str)
	{
		
	}
	
}

char	*erase_in_line(char *str, int i)
{
	//str trim & join
	
}

char    *parsing(char *line_to_pars, t_struct *data)
{
    int		i;
	int		y;
    char	*tmp;

    i = 0;
    while (line_to_pars[i])
    {
		if (line_to_pars[i] == '$')
		{
			y = i;
			while (line_to_pars[y] != ' ')
				y++;
			tmp = malloc(sizeof(char *) * (y - i) + 1);
			if (!tmp)
				return (NULL);
			tmp = ft_strlcpy(tmp, line_to_pars, (y - i));
			tmp = var_exist(data, tmp);
			if (tmp)
				line_to_pars = replace_in_line(line_to_pars, extract_var(tmp), i);
			else
				line_to_pars = erase_in_line(line_to_pars, i);
		}
		i++;
    }
	free(tmp);
    return(line_to_pars);
}
